import{b as o,o as s,w as n,g as e,D as u,v as i,x as d,z as a}from"./modules/vue-DFpLUG3R.js";import{I as c}from"./slidev/default-D1cBHkmE.js";import{u as p,f as m}from"./slidev/context-CKl0HDSr.js";import"./index-BjCohSjP.js";import"./modules/shiki-Cef1cqCC.js";const v={__name:"slides.md__slidev_11",setup(f){const{$clicksContext:r,$frontmatter:l}=p();return r.setup(),(_,t)=>(s(),o(c,i(d(a(m)(a(l),10))),{default:n(()=>[...t[0]||(t[0]=[e("h1",null,"3. Дип‑дайв — Event‑driven уведомления",-1),e("h3",null,"Scheduling:",-1),e("ul",null,[e("li",null,"Реал‑тайм: для мгновенных алертов alert.created сразу отправляется в Kafka/alerts-topic и обрабатывается без задержки."),e("li",null,[u("Для дайджестов и отложенных алертов можем применить один из двух подходов: "),e("ul",null,[e("li",null,"DB scheduler — alert сначала пишется только в таблицу pending_alerts в БД c полем next_send_at, надёжно хранится там до наступления времени отправки; периодический worker выбирает «созревшие» записи и только тогда паблишит в Kafka, после чего алерт консумится downstream‑сервисами. (Для быстрого lookup и throttle лимитов можно строить проекцию этого состояния в Redis, но durable storage — только БД)."),e("li",null,"Kafka Streams windows (punctuator) — alert.created сразу кладётся в топик; потоковое приложение держит их внутри окон до dueAt и пускает дальше только «созревшие» алерты.")])])],-1)])]),_:1},16))}};export{v as default};
